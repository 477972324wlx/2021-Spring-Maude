fmod LIST-NAT is
  protecting NAT .

  sort List-Nat .
  subsort Nat < List-Nat .

  op nil :      -> List-Nat [ctor ] .
  
  op _,_ : List-Nat List-Nat -> List-Nat [ctor assoc id: nil ] .   ----space is required
 
  var x : Nat .
  var z : Nat .
  var y : List-Nat .

  op len : List-Nat -> Nat .
  eq len (nil) = 0 .
  eq len (x,y) = 1 + len(y) .

  op rev : List-Nat -> List-Nat .
  eq rev(nil) = nil .
  eq rev(x) = x .
  eq rev(x,y) = rev(y),x .

  op getL1 : Nat List-Nat -> List-Nat .
  eq getL1 (x,z) = (if z < x then z else nil fi) .
  eq getL1 (x,(z,y)) = (if z < x then (z,getL1(x,y)) else getL1(x,y) fi) .

  op getL2 : Nat List-Nat -> List-Nat .
  eq getL2 (x,z) = (if z >= x then z else nil fi) .
  eq getL2 (x,(z,y)) = (if z >= x then (z,getL2(x,y)) else getL2(x,y) fi) .

  op sort : List-Nat -> List-Nat .
  eq sort (nil) = nil .
  eq sort (x) = x .
  eq sort (x,y) = sort(getL1(x,y)),x,sort(getL2(x,y))  .

endfm

fmod BTree is
  protecting NAT .

  sort Leaf Btree .
  ----subsort Nat < Btree .


  op ((_,_,_)) : Btree Nat Btree -> Btree [ctor] .
  op nil : -> Btree [ctor] .
 
  var root  : Btree .
  var lson  : Btree .
  var rson  : Btree .
  var value : Nat .
  var pivot : Nat .
  
  op JudgeSubtreeLess : Btree Nat -> Bool .
  eq JudgeSubtreeLess(nil,pivot) = true .
  eq JudgeSubtreeLess((lson,value,rson), pivot) = ( if(value > pivot) then false else JudgeSubtreeLess(lson,value) and JudgeSubtreeLess(rson,pivot) fi) .

  op JudgeSubtreeGreat : Btree Nat -> Bool .
  eq JudgeSubtreeGreat(nil,pivot) = true .
  eq JudgeSubtreeGreat((lson,value,rson), pivot) = ( if(value < pivot) then false else JudgeSubtreeGreat(lson,value) and JudgeSubtreeGreat(rson,pivot) fi) .

  op isBSTree : Btree -> Bool .
  eq isBSTree(nil) = true .
  eq isBSTree((lson,value,rson)) = JudgeSubtreeLess(lson,value) and JudgeSubtreeGreat(rson,value) and isBSTree(lson) and isBSTree(rson) .
  

  --- op Insert : Tree Nat -> Tree .
  --- eq Insert(nil, x) = x,nil,nil .
endfm

  